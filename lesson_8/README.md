# Контрольные вопросы
- [Контрольные вопросы](#контрольные-вопросы)
    - [Способы обработки ошибок](#способы-обработки-ошибок)
    - [Недостатки механизма кодов возврата](#недостатки-механизма-кодов-возврата)
    - [Особенности механизма исключений](#особенности-механизма-исключений)
    - [noexcept](#noexcept)
        - [Спецификация исключений](#спецификация-исключений)
        - [Спецификатор noexcept](#спецификатор-noexcept)
        - [Оператор noexcept](#оператор-noexcept)
    - [Гарантии безопасности исключений](#гарантии-безопасности-исключений)
        - [Базовая гарантия](#базовая-гарантия)
        - [Строгая гарантия](#строгая-гарантия)
        - [Отсутствие исключений](#отсутствие-исключений)

### Способы обработки ошибок

- Запускать код только в случае отсуствия предполагаемой ошибки: 
    ```cpp
        if(index < arrayLength && index+1)
            std::cout<<array[index];
    ```
- Придумать **код ошибки** для функции:
    ```cpp
        if(index >= arrayLength || index < 0)
            return -1; 
        return index;
            /*считаем, что функция должна 
            вернуть целое неотрицательное значение
            Поэтому в качестве кодов ошибки 
            уместно использовать
            целые отрицательные числа 
            */ 
    ```
- Сообщения об ошибках можно выводить в консоль. Для этого в C++ придуман отдельный поток вывода `cerr`:
    ```cpp
        if(index >= arrayLength || index < 0)
        {
            std::cerr<<"Array index out of range";
            return -1;
        }
        return index;
    ```
- При возникновении ошибки можем завершать выполнение программы:
    ```cpp
        if(index >= arrayLength || index < 0)
        {
            /*тут следует очистить динамически 
            выделенную память*/
            /* в консоль можем вывести причину возникновения ошибки*/
            exit();
        }
        return index;
    ```
    > данный способ лучше сочетать со способом возвращения кодов ошибки. Ведь в вызываемой функции не всегда доступны динамически выделенные объекты
- Использовать макрос `assert`. Данный способ похож на предыдущий. Макрос `assert` проверяет корректность выражения, и если выражение некорректно выводит сообщение об ошибке:
    ```cpp
        assert(index >= arrayLength || index < 0);
        return index;
    ```
- Создавать и обрабатывать исключения при помощи опреаторов `try`, `catch`, `throw`:
    ```cpp
        try
        {
            if(index >= arrayLength || index < 0)
                throw "Array index out of range error";
            return index;
        }
        catch(const char* errorString)
        {
            /*тут решаем каким
             способом обработать полученную ошибку*/
        }
    ```

### Недостатки механизма кодов возврата 

- Не во всех функциях можно придумать корректный код возврата:
    ```cpp
    int getElByIndex(int* arr, int index)
    {
        if(index >= arrayLength || index < 0)
            return -1; 
        return arr[index];
        /*код возврата -1 некорректен 
        -1 может являться элементом массива  */
    }
    ```
    > в данном примере невозможно придумать корректный код возврата
- Код становится нечитаемым. Стороннему программисту сложно понять почему для определённых возвращаемых объектов существует специальная обработка.
- Обработкой кода возврата может заниматься только функция `caller`. В противном случае придётся придумывать код возврата для кода возврата для кода возврата...
- Ошибка становится *неуловимой* для программиста, если код возврата не был обработан. Нет способа посмотреть на все коды возврата, сгенерированные программой.

### Особенности механизма исключений

1. Механизм исключений может генерировать ошибки любого типа данных
2. Обработка исключений может происходить вне функции, вызывающей исключения
3. Для обработки всех исключений сгенерированных программой предусмотрен блок **catch-all** - `catch(...)`
4. При возникновении необработанных исключений программа завершится, и программист будет уведомлен о возникновении исключения. 
5. Программист имеет возможность явно указать генерирует ли данная функция исключения. Так же имеется возможность указать тип выбрасываемых исключений 

### noexcept

##### Спецификация исключений

В C++ предусмотрен способ явно указать тип данных выбрасываемых исключений:
```cpp
type function(args) throw(throwTypes)
```
В качестве `throwTypes` следует указывать типы исключений, которые генерирует функция. При этом:
- `throwTypes` = ` ` - функция не генерирует исключений
- `throwTypes` = `...` - функция может генерировать все исключения

Однако вышеописанный синтаксис поддерживается не всеми компилляторами. Например компиллятор g++ версии 6.3.0 выводит ошибку:
>ex1.cpp:3:20: error: expected type-specifier before '...' token
 int myFunc() throw(...)

Механизм спецификации исключений может быть реализован другими способами, которые будут рассмотрены ниже.


##### Спецификатор noexcept

Спецификатор `noexcept` позволяет явно указать, что данная функция не выбрасывает исключений:
```cpp
type function(args) noexcept
```

Если при реализации функции будет выброшено какое-либо исключение - получим предупреждение в консоль:
```cpp
int myFunc(int alpha) noexcept
{
        if(alpha == 0)
                throw "lalala";
        return 10;
}
```
> ex1.cpp: In function 'int myFunc(int)':
ex1.cpp:6:9: warning: throw will always call terminate() [-Wterminate]
   throw "lalala";
         ^~~~~~~

Чтобы указать, что функция может выбрасывать исключения используем синтаксис:
```cpp
type function(args) noexcept(false)
```

##### Оператор noexcept

Оператор `noexcept` используется для проверки выражений. Если выражение может выбросить исключение, оператор возвращает `false`, в противном случае - `true`.

### Гарантии безопасности исключений

##### Базовая гарантия

Не должно возникнуть утечек ресурсов:
- Все динамически выделенные данные должны быть очищены. 
- Инварианты не нарушены. 

##### Строгая гарантия

Каждая новая операция сначала сохраняет состояние программы, а затем начинает своё выполнение. 
Если при выполнении операции возникает ошибка программа возвращается в ранее сохранённое состояние.

##### Отсутствие исключений 

Функция/метод не генерирует исключения.





