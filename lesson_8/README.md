# Контрольные вопросы
- [Контрольные вопросы](#контрольные-вопросы)
    - [Способы обработки ошибок](#способы-обработки-ошибок)
    - [Недостатки механизма кодов возврата](#недостатки-механизма-кодов-возврата)
    - [Особенности механизма исключений](#особенности-механизма-исключений)
    - [noexcept](#noexcept)
        - [Спецификация исключений](#спецификация-исключений)
        - [Спецификатор noexcept](#спецификатор-noexcept)
        - [Оператор noexcept](#оператор-noexcept)
    - [Гарантии безопасности исключений](#гарантии-безопасности-исключений)
        - [Базовая гарантия](#базовая-гарантия)
        - [Строгая гарантия](#строгая-гарантия)
        - [Отсутствие исключений](#отсутствие-исключений)
- [Задание 4](#задание-4)
        - [Нормальные пути выполнения:](#нормальные-пути-выполнения)
        - [Пути выполнения с исключениями](#пути-выполнения-с-исключениями)

### Способы обработки ошибок

- Запускать код только в случае отсуствия предполагаемой ошибки: 
    ```cpp
        if(index < arrayLength && index+1)
            std::cout<<array[index];
    ```
- Придумать **код ошибки** для функции:
    ```cpp
        if(index >= arrayLength || index < 0)
            return -1; 
        return index;
            /*считаем, что функция должна 
            вернуть целое неотрицательное значение
            Поэтому в качестве кодов ошибки 
            уместно использовать
            целые отрицательные числа 
            */ 
    ```
- Сообщения об ошибках можно выводить в консоль. Для этого в C++ придуман отдельный поток вывода `cerr`:
    ```cpp
        if(index >= arrayLength || index < 0)
        {
            std::cerr<<"Array index out of range";
            return -1;
        }
        return index;
    ```
- При возникновении ошибки можем завершать выполнение программы:
    ```cpp
        if(index >= arrayLength || index < 0)
        {
            /*тут следует очистить динамически 
            выделенную память*/
            /* в консоль можем вывести причину возникновения ошибки*/
            exit();
        }
        return index;
    ```
    > данный способ лучше сочетать со способом возвращения кодов ошибки. Ведь в вызываемой функции не всегда доступны динамически выделенные объекты
- Использовать макрос `assert`. Данный способ похож на предыдущий. Макрос `assert` проверяет корректность выражения, и если выражение некорректно выводит сообщение об ошибке:
    ```cpp
        assert(index >= arrayLength || index < 0);
        return index;
    ```
- Создавать и обрабатывать исключения при помощи опреаторов `try`, `catch`, `throw`:
    ```cpp
        try
        {
            if(index >= arrayLength || index < 0)
                throw "Array index out of range error";
            return index;
        }
        catch(const char* errorString)
        {
            /*тут решаем каким
             способом обработать полученную ошибку*/
        }
    ```

### Недостатки механизма кодов возврата 

- Не во всех функциях можно придумать корректный код возврата:
    ```cpp
    int getElByIndex(int* arr, int index)
    {
        if(index >= arrayLength || index < 0)
            return -1; 
        return arr[index];
        /*код возврата -1 некорректен 
        -1 может являться элементом массива  */
    }
    ```
    > в данном примере невозможно придумать корректный код возврата
- Код становится нечитаемым. Стороннему программисту сложно понять почему для определённых возвращаемых объектов существует специальная обработка.
- Обработкой кода возврата может заниматься только функция `caller`. В противном случае придётся придумывать код возврата для кода возврата для кода возврата...
- Ошибка становится *неуловимой* для программиста, если код возврата не был обработан. Нет способа посмотреть на все коды возврата, сгенерированные программой.

### Особенности механизма исключений

1. Механизм исключений может генерировать ошибки любого типа данных
2. Обработка исключений может происходить вне функции, вызывающей исключения
3. Для обработки всех исключений сгенерированных программой предусмотрен блок **catch-all** - `catch(...)`
4. При возникновении необработанных исключений программа завершится, и программист будет уведомлен о возникновении исключения. 
5. Программист имеет возможность явно указать генерирует ли данная функция исключения. Так же имеется возможность указать тип выбрасываемых исключений 

### noexcept

##### Спецификация исключений

В C++ предусмотрен способ явно указать тип данных выбрасываемых исключений:
```cpp
type function(args) throw(throwTypes)
```
В качестве `throwTypes` следует указывать типы исключений, которые генерирует функция. При этом:
- `throwTypes` = ` ` - функция не генерирует исключений
- `throwTypes` = `...` - функция может генерировать все исключения

Однако вышеописанный синтаксис поддерживается не всеми компилляторами. Например компиллятор g++ версии 6.3.0 выводит ошибку:
>ex1.cpp:3:20: error: expected type-specifier before '...' token
 int myFunc() throw(...)

Механизм спецификации исключений может быть реализован другими способами, которые будут рассмотрены ниже.


##### Спецификатор noexcept

Спецификатор `noexcept` позволяет явно указать, что данная функция не выбрасывает исключений:
```cpp
type function(args) noexcept
```

Если при реализации функции будет выброшено какое-либо исключение - получим предупреждение в консоль:
```cpp
int myFunc(int alpha) noexcept
{
        if(alpha == 0)
                throw "lalala";
        return 10;
}
```
> ex1.cpp: In function 'int myFunc(int)':
ex1.cpp:6:9: warning: throw will always call terminate() [-Wterminate]
   throw "lalala";
         ^~~~~~~

Чтобы указать, что функция может выбрасывать исключения используем синтаксис:
```cpp
type function(args) noexcept(false)
```

##### Оператор noexcept

Оператор `noexcept` используется для проверки выражений. Если выражение может выбросить исключение, оператор возвращает `false`, в противном случае - `true`.

### Гарантии безопасности исключений

##### Базовая гарантия

Не должно возникнуть утечек ресурсов:
- Все динамически выделенные данные должны быть очищены. 
- Инварианты не нарушены. 

##### Строгая гарантия

Каждая новая операция сначала сохраняет состояние программы, а затем начинает своё выполнение. 
Если при выполнении операции возникает ошибка программа возвращается в ранее сохранённое состояние.

##### Отсутствие исключений 

Функция/метод не генерирует исключения.

# Задание 4
```cpp
String evaluate_salary_and_return_name(Employee e)
{
    if (e.title () == "CEO" || e.salary () > 100000)
    {
        std:: cout << e.name () << " " << e.surname () << " is overpaid .\n";
    }
    else
    {
        std:: cout << e.name () << " is not overpaid .\n";
    }
    return e.name () + " " + e.surname ();
}
```
##### Нормальные пути выполнения:

1. Если `e.title() == "CEO"` истинно, то метод `e.salary()` не вызывается, получаем путь:
    ```mermaid
    graph LR
    e.salary --> std::cout..is_overpaid--> return...
    ```
2. Если `e.title() == "CEO"` ложно, то будет проверяться вторая часть выражения. Если вторая часть выражения истинна получим путь:
    ```mermaid
    graph LR
    e.title --> e.salary --> std::cout...is_overpaid --> return...
    ```
3. Если обе части выражения ложны - выполняется код, расположенный в блоке else. Путь выполнения:
    ```mermaid
    graph LR
    e.title --> e.salary --> std::cout...is_not_overpaid --> return...
    ```

##### Пути выполнения с исключениями

1. Функция `evaluate_salary_and_return_name` принимает аргумент по значению -> происходит вызова конструктора копирования класса `Employee`, который может генерировать исключения. **1 путь** 
2. В теле функции вызывается 5 методов класса:
    - `.title()`
    - `.salary()`
    - `.name()`
    - `.surname()`
    - `~Employee()` (при выходе объекта `e` из области видимости функции)
    - **Итог 5 путей**
3. Исключения могут быть вызваны операторамми
    - `==` - если операция нереализована для данных операндов
    - `>`
    - `<<` - если нет реализации оператора вывода для возращаемого типа методов `name()` и `surname()` - всего три пути
    - `<<` - еще три пути. Например реализация оператора вывода не возвращает объект `std::ostream` и не может принять на вход строку
    - `+` - два пути. Например при отсутвии реализации оператора для операндов `type(e.name())` и `std::string`
    - `||`
    - **Итого операторами может быть брошено 1+1+3+3+2+1 = 11 исключений**
4. Допустим существует реализация оператора плюс для `type(e.name())` и типа данных `A != std::string, != char*...`. Тогда компиллятор может попробовать привести `" "` к типу `A`. Получим исключение `...cast`. 
5. Если реализация операторов принимает объекты по значению, происходит копирование объекта в функцию оператора. Следовательно у объектов типа `e.name()`, `e.salary()` ... будет вызван конструктор копирования. Это может привести к возникновению исключений. **Еще 9 путей** 

**Итого путей с иключениями 1+5+11+1+9 = 27**

**Итог 27+3 = 30**


