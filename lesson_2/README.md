# Занятие 2

## Алгоритм поиска НОП
![Alt Text](https://github.com/ShmakovVladimir/CplusplusHOMEWORK/blob/main/lesson_2/pics/GCS.excalidraw.png)

## Алгоритм бинарного поиска
![Alt Text](https://github.com/ShmakovVladimir/CplusplusHOMEWORK/blob/main/lesson_2/pics/binSearch.png)

## Ответы на контрольные вопросы

### Из каких сегментов состоит структура памяти процессора?

Современные операционные системы многозадачны - умеют выполнять несколько процессов одновременно. Любая программа требует некотрое количество памяти для своей работы. Эта память используется для хранения различных состояний нашей программы - например браузеру требуется хранить адреса открытых вкладок... В целях многозадачности - каждой программе выделяется лишь часть памяти компьютера, называемая **виртуальным адресным пространством**. 

<<Виртуальные адреса>> никак не связаны с физическими. Задача преобразования виртуального адреса в физический лежит на операционной системе.

Размер вирутального адреса и размер виртуального адресного пространства зависит от **разрядности** операционной ситемы. **Разрядность ОС** - размер, который занимает указатель(виртуальный адрес). В случае 32 битных ситем указатель занимает всего 4 байта. Что позволяет получать доступ к `2^(32)` байтам. Таким образом - виртуальное адресное пространство в 32битной системе занимает `(2^(32))/(10^9) = ` 4.3 гигабайта(но в ![документации windows](https://docs.microsoft.com/ru-ru/windows/win32/memory/virtual-address-space) пишут что 4). 

Половину адресного простраства занимают процессы ОС(0x80000000 до 0xFFFFFFFF). Вторая половина выделяется для нашей программы.

В случае 64битных систем все сложнее. Несложно посчитать, что там адресное пространство занимает несколько террабайт. Но, судя по ![документации](https://docs.microsoft.com/ru-ru/windows/win32/winprog64/virtual-address-space), ОС ограничивает виртуальное адресное пространство, и выделяет дополнительную память лишь при необходимости.

Как происходит хранение данных в виртуальном адресном пространстве? Для разных задач используются разные сегменты выделенной памяти. Всего сегментов семь:

- **Kernel space** - пространство, выделенное для операционной системы. 
    - В случае win32 занимает 2 гигабайта. В случае Linux - 1.
    - Программа не имеет доступа к данному сегменту. Если случайно набрать адрес из этого сегмента возможно получение ошибки:
<pre></pre><br><code>
#include <iostream>
int main(){
    int *p = (int*)0x8F00FF10;
    *p = 100;
    std::cout<<*p;
    return 0;
}
    </code></br>
    > После компилляции и запуска - программа не вывела в консоль желланое `100`. Отсуствовала надпись `Program finished with exit code 0`. 
- **Стек** - сегмент для хранения локальных параметров функций. Там хранятся локальные переменные, адреса возврата.
    - Стек реализован по принципу **LIFO** - last in first out. Этоу концепцую легко представить. Допустим мы печем блины. После того, как тесто достаточно затвердеет, готовый блин кладётся на тарелку. Какой же блин мы съедим первым? Верно - тот, который был испечен в самом конце и сейчас находится на самой верхушке блинной башенки.
    Похожим образом устроен стек - функция хранит свои данные в некоторой области(блинчике). Если из функции вызывается другая, то создаётся новый блинчик. В новоиспеченном блине содержится **адрес возврата** - адрес по которому нужно вернуть результат работы функции. Первая функция закончит свою работу лишь тогда, когда получит все необходимые данные от других фукнций. Теперь несложно понять, что функция `main` последеней выходит из стека. По своему <<адресу возврата>> она передаёт ноль, что является индикатором успешного завершения программы.
    - Размер стека достаточно мал(гугл пишет, что 1Мб). Поэтому с ним нужно работать аккуратно. Если вызвать в нем множество функций(или поместить большие данные), получим ошибку `stack overflow` - переполнение стека. В этом несложно убедиться на примере бесконечной рекурсии.
- **Куча** - служит для хранения динамически выделенных данных. Куча имеет достаточно большой размер. Поэтому именно там следует хранить объёмные данные. Скажем нам нужно сохранить волновую форму длительностью 10 секунд, и записанную с битрейтом 96khz. Для этого требуется массив из 960000 элементов типа float. Сохранить такой массив в стеке невозможно, ведь он занимает `96000*10*32/(1.25*(10^7))` примерно 2Мб. 
- **BSS/Data** - хранит статически выделенные глобальные переменные. Между этими сегментами есть небольшие различия, но они не так важны при работе.
- **Text** - программа представляет из себя бинарный файл с инструкциями для компьютера. Именно из этого сегмента компьютер получает инструкци к выполнению.


        

    


